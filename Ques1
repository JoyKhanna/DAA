#include <bits/stdc++.h>
using namespace std;

/*
 Returns tuple (best_sum, l, r) where l..r inclusive is the subarray
 whose sum is closest to k.
*/
tuple<long long,int,int> subarray_sum_closest(const vector<long long>& a, long long k) {
    int n = (int)a.size();
    vector<long long> pref(n+1, 0);
    for (int i = 0; i < n; ++i) pref[i+1] = pref[i] + a[i];

    // multiset of pairs (prefix value, index) to retrieve the original index for subarray.
    // We'll store pair(prefix_value, index)
    set<pair<long long,int>> s;
    s.insert({0LL, 0}); // prefix at index 0

    long long bestDiff = LLONG_MAX;
    long long bestSum = 0;
    int bestL = 0, bestR = 0;

    for (int j = 0; j < n; ++j) {
        long long pj = pref[j+1];
        long long target = pj - k; // we want pref[i] close to this

        // lower_bound on set by pair (target, -INF) so it finds first with prefix >= target
        auto it = s.lower_bound({target, numeric_limits<int>::min()});

        // check candidate it
        if (it != s.end()) {
            long long candPref = it->first;
            int i = it->second;
            long long sum = pj - candPref; // sum of subarray [i, j]
            long long diff = llabs(sum - k);
            if (diff < bestDiff) {
                bestDiff = diff;
                bestSum = sum;
                bestL = i;
                bestR = j;
            }
        }

        // check predecessor
        if (it != s.begin()) {
            auto it2 = prev(it);
            long long candPref = it2->first;
            int i = it2->second;
            long long sum = pj - candPref;
            long long diff = llabs(sum - k);
            if (diff < bestDiff) {
                bestDiff = diff;
                bestSum = sum;
                bestL = i;
                bestR = j;
            }
        }

        // insert current prefix with its index (j+1)
        s.insert({pj, j+1});
    }

    return {bestSum, bestL, bestR};
}

// Example usage
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; long long k;
    if (!(cin >> n >> k)) return 0;
    vector<long long> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];

    auto [sum, l, r] = subarray_sum_closest(a, k);
    cout << "Best subarray sum = " << sum << " (indices " << l << " to " << r << " inclusive)\n";
    return 0;
}
